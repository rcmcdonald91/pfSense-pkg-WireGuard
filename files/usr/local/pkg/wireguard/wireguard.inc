<?php

require_once("globals.inc");
require_once("config.inc");
require_once("pfsense-utils.inc");
require_once("system.inc");
require_once("service-utils.inc");
require_once("util.inc");

# Rather than the traditional "wg0" name, we prefix with "tun" so that pfSense
# doesn't freak out about non-existant interfaces on boot and instead just ignores
# it. Technically wireguard interfaces are tun anyway, so we aren't lying.
global $ifname;
$ifname = "tunwg0";







function wireguard_resync() {
	global $config, $configpath, $ifname;
	$configpath = "/usr/local/etc/wireguard/{$ifname}.conf";

	if (is_array($config['installedpackages']['wireguard']['config'][0])) {
		$ifconf = $config['installedpackages']['wireguard']['config'][0];
	} else {
		$ifconf = array();
	}

	# See if we need to create new private and public keys for the interface.
	if ($ifconf['genkeys']) {
		$ifconf['privatekey'] = base64_encode(wireguard_generate_privkey());
		$ifconf['publickey'] = base64_encode(wireguard_generate_pubkey(base64_decode($ifconf['privatekey'])));

		$config['installedpackages']['wireguard']['config'][0]['privatekey'] = $ifconf['privatekey'];
		$config['installedpackages']['wireguard']['config'][0]['publickey'] = $ifconf['publickey'];
		$config['installedpackages']['wireguard']['config'][0]['genkeys'] = false;

		# Trigger a resync to update the package config again.
		write_config("[wireguard] Generated new private/public key pair.");
		log_error("[wireguard] Generated new private/public key pair.");
	}

	# Set up the interface config.
	$output = "[Interface]\n";
	$output .= "# Generated by pfSense\n";

	$address = implode(",", explode("\r\n", base64_decode($ifconf["address"])));
	$output .= "Address = {$address}\n";

	$listenport = $ifconf["listenport"];
	if ($listenport) {
		$output .= "ListenPort = {$listenport}\n";
	}

	$dns = implode(",", explode("\r\n", base64_decode($ifconf["dns"])));
	if ($dns) {
		$output .= "DNS = {$dns}\n";
	}

	$privatekey = base64_decode($ifconf["privatekey"]);
	$output .= "PrivateKey = {$privatekey}\n";

	$table = $ifconf["table"];
	if ($table) {
		$output .= "Table = {$table}\n";
	}

	$mtu = $ifconf["mtu"];
	if ($mtu) {
		$output .= "MTU = {$mtu}\n";
	}

	$preup = explode("\r\n", base64_decode($ifconf["preup"]));
	if ($preup[0] <> "") {
		foreach ($preup as $entry) {
			$output .= "PreUp = {$entry}\n";
		}
	}

	$postup = explode("\r\n", base64_decode($ifconf["postup"]));
	if ($postup[0] <> "") {
		foreach ($postup as $entry) {
			$output .= "PostUp = {$entry}\n";
		}
	}

	$predown = explode("\r\n", base64_decode($ifconf["predown"]));
	if ($predown[0] <> "") {
		foreach ($predown as $entry) {
			$output .= "PreDown = {$entry}\n";
		}
	}

	$postdown = explode("\r\n", base64_decode($ifconf["postdown"]));
	if ($postdown[0] <> "") {
		foreach ($postdown as $entry) {
			$output .= "PostDown = {$entry}\n";
		}
	}

	$i = 0;
	if (!empty($config['installedpackages']['wireguardpeers']['config'])) {
		foreach ($config['installedpackages']['wireguardpeers']['config'] as $peerconf) {
			# See if we need to create a preshared key for the peer.
			if ($peerconf["genpsk"]) {
				$peerconf['psk'] = base64_encode(wireguard_generate_psk());

				$config['installedpackages']['wireguardpeers']['config'][$i]['psk'] = $peerconf['psk'];
				$config['installedpackages']['wireguardpeers']['config'][$i]['genpsk'] = false;

				# Trigger a resync to update the package config again.
				write_config("[wireguard] Generated new preshared key.");
				log_error("[wireguard] Generated new preshared key.");
			}

			# Set up the peer config.
			$output .= "\n[Peer]\n";
			$output .= "# {$peerconf['name']}\n";

			$endpoint = $peerconf['endpoint'];
			if ($endpoint) {
				$output .= "Endpoint = {$endpoint}\n";
			}

			$pubkey = base64_decode($peerconf['publickey']);
			$output .= "PublicKey = {$pubkey}\n";

			$allowedips = implode(",", explode("\r\n", base64_decode($peerconf["allowedips"])));
			$output .= "AllowedIPs = {$allowedips}\n";

			$psk = base64_decode($peerconf['psk']);
			if ($psk) {
				$output .= "PresharedKey = {$psk}\n";
			}

			$keepalive = $peerconf['keepalive'];
			if ($keepalive <> "") {
				$output .= "PersistentKeepalive = {$keepalive}\n";
			}

			$i++;
		}
	}

	# Write out the config file.
	file_put_contents($configpath, $output);
}

function wireguard_write_rcfile() {
	$configPaths = glob('/usr/local/etc/wireguard/*.conf');
	if (empty($configPaths)) {
		$configPaths = ['tunwg0.conf'];
	}

	$start = $stop = [];
	foreach ($configPaths as $configPath) {
		$ifname = basename($configPath, '.conf');
		$start[] = "/usr/local/bin/wg-quick up {$ifname} && /etc/rc.filter_configure";
		$stop[] = "/usr/local/bin/wg-quick down {$ifname}";
	}

	$rcfile['file'] = 'wireguard.sh';
	$rcfile['start'] = implode("\n\t", $start);
	$rcfile['stop'] = implode("\n\t", $stop);
	write_rcfile($rcfile);
	unlink_if_exists("/usr/local/etc/rc.d/wireguard");
}

function wireguard_install() {
	wireguard_write_rcfile();
}

# $_SERVER['REQUEST_URI'] == "/pkg_edit.php?xml=wireguard.xml";
# $_SERVER['QUERY_STRING'] == "xml=wireguard.xml";
# $_SERVER['PHP_SELF'] == "/pkg_edit.php";
if ($_SERVER['PHP_SELF'] == "/pkg_edit.php") {
	echo "<script type='text/javascript' src='wireguard.js'></script>\n";
}
?>
